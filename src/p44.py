#-*- coding: utf-8 -*-

from p import Problem

from math import sqrt

class p44(Problem):

    """
        Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
        1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
        It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.
        Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = |Pk − Pj| 
        is minimised; what is the value of D?

    """


    def __compute_max_bound(self, k):
        """
            À partir d'un nombre k, calcule le premier entier n tel que 
            l'écart entre P(n) et P(n+1) soit strictement plus grand que k.
            Cela donne une borne supérieure sur i et j pour trouver des nombres 
            pentagonaux tels que Pj - Pi < k

        """
        return (k - 1) / 3 + 1

    
    def __is_pent(self, x):
        """
            Retourne true si x est un nombre pentagonal, false sinon

        """
        n = (sqrt(24*x + 1) + 1)/6.
        return n.is_integer()


    def test_pent(self):
        """
            Fonction test pour tester l'implémentation de __is_pent

        """

        res_test = True

        # Teste si la réponse est bien 'true' pour des nombres pentagonaux
        for n in xrange(1, 50):
            p = n * (3 * n - 1) / 2
            if (not self.__is_pent(p)):
                print "[err] {0} is the {1}-th pentagonal number (__is_pent returned false)".format(p, n)
                res_test = False
        # Teste si la réponse est bien 'false' pour des nombres non pentagonaux
        for n in xrange(1, 50):
            p = n * (3 * n - 1) / 2 + 1
            if (self.__is_pent(p)):
                print "[err] {0} is not a pentagonal number (__is_pent returned true)".format(p)
                res_test = False

        return res_test


    def p(self, n):
        """
            Retourne le nè nombre pentagonal

        """

        return n * (3*n - 1) / 2


    def update(self, j, k, senti, sup):
        """
            Update the index of the loop. From the current values of j and k, 
            look for the next couple j, k such that pj and pk are pentagonal
            numbers of distance senti, with j < k <= sup
            If there is not such couple, return (1, sup + 1). In this way,
            we ensure that P(1) and P(sup + 1) are at distance at least senti + 1, 
            which will lead to the next iteration on senti in the main loop.

        """

        k += 1
        pj = self.p(j)
        pk = self.p(k)
        while (j < sup and (pk - pj) != senti):
            if k < sup:
                k += 1
            else:
                j += 1
                k = j + 1
            pj = self.p(j)
            pk = self.p(k)
    
        if (j < sup):
            return (j, k)
        else:
            return (1, sup + 1)


    # l'intervalle entre P(n) et P(n+1) vaut 3n + 1 => intervalle strictement croissant
    def solve(self):
        
        senti = 2
        d = -1
        while d == -1:
            if senti % 100 == 0:
                print "[log] Testing with a distance of {0}".format(senti)
            senti += 1
            sup = self.__compute_max_bound(senti)
            j, k = self.update(1, 1, senti, sup)
            pj = self.p(j)
            pk = self.p(k)
            while (pk - pj <= senti):
                if  self.__is_pent(pk - pj) and self.__is_pent(pk + pj):
                    d = pk - pj
                    break
                else:
                    j, k = self.update(j, k, senti, sup)
                    pj = self.p(j)
                    pk = self.p(k)
                        
            
        return d


if __name__ == "__main__":
    p = p44(44)
    if p.test_pent():
        print "[ok] Tests successful."
    else:
        print "[ko] Some tests failed."

